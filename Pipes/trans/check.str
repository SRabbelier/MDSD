module check

imports
  libstratego-lib
  include/Pipes
  lib/editor-common.generated

rules

  // Analysis: does a topdown traversal of the tree,
  // and tries to apply the record-entity rule.
  analyze:
    t -> t
    with
      <topdown(try(record-entity))> t

  // Records the definition of an entity in a dynamic rule GetEntity.
  record-entity:
    p@Pipe(PipeName(x), _, _, _, _) -> p
    with
      // For a name 'x', GetPipe will return the original 'x' tree node
      rules(
        GetCustom :+ x -> p
    	GetPipe :+ x -> p
      )
  record-entity:
    n@Native(PipeName(x), _, _, _) -> n
    with
      rules(
    	GetNative :+ x -> n
    	GetPipe :+ x -> n
      )
  
	
	
rules
      
  get-name:
  	FunctionApplication(PipeName(p), _) -> p
  	  
  get-args:
  	LambdaFunction(None(), _) -> []  
  	
  get-args:
  	LambdaFunction(FunctionArguments(t), _) -> t

  get-args:
  	Pipe(_, _, NoArguments(), _, _) -> []

  get-args:
  	Pipe(_, _, Arguments(VariableList(a)), _, _) -> a
  
  get-args:
  	Native(_, _, NoArguments(), _) -> []
	  
  get-args:
  	Native(_, _, Arguments(VariableList(a)), _) -> a
	  

  checkParam(|target):
  	[[Variable(param)|rest], args] -> errors
  	where errs :=  <checkParam(|target)>[rest, args] 
  	where (<fetch-elem(?FunctionArgument(param,_))> args) < errors:=<id>errs + errors:=<missingParam(|errs, target)>param
  
  checkParam(|target):
  	[[], _] -> []	

  missingParam(|errors, target):
  	x -> [(target, $[Missing argument '[x]']), errors]
  
  checkArgs:
  	[param, [f@FunctionArgument(x,_)|rest]] -> errors
  	where errs := <checkArgs>[param, rest]
  	where (<fetch-elem(?Variable(x))> param) <  errors:=<id>errs + errors:=<invArg(|errs)>f

  checkArgs:
  	[_, []] -> []

  invArg(|errors):
  	f@FunctionArgument(x,_) -> [(f, $[Invalid argument '[x]']), errors]


  is-empty:
  	[] -> <id>
  is-empty:
  	[_] -> <fail>
  	
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    FunctionApplication(PipeName(p), t) -> (p, $[Pipe '[p]' is not defined])
    where
      not(<GetPipe> p) // no entity for this type
  
  constraint-error:
  	LambdaFunction(Some(FunctionArguments(args)), app) -> [errors, errors2]
    where p := <get-name>app
    where pargs := <get-args><GetPipe> p 
	  // Check that all arguments are expected parameters
    where errors := <checkArgs>[pargs, args]
	  // Check that all required arguments are provided
    where errors2 := <checkParam(|app)>[pargs, args]
    
  constraint-error:
	  // Check that all required arguments are provided
  	f@LambdaFunction(None(), app) -> errors
    where p := <get-name>app
    where pargs := <get-args><GetPipe> p 
    where errors := <checkParam(|app)>[pargs, []]
  	
  // Reports an error if an entity is defined more than once.
  // This constraint is implemented by testing if the "bag" of
  // all entities x is not a singleton list.
  constraint-error:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Duplicate pipe name '[x]'])
    where
      not(<bagof-GetCustom> x => [_])

  constraint-error:
    Native(PipeName(x), _, _, _) -> (x, $[Duplicate native name '[x]'])
    where
      not(<bagof-GetNative> x => [_])
  
  constraint-warning:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Shadowing native pipe])
    where
      (<bagof-GetNative> x => [_])
  
  constraint-note:
    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
                                      (this note is defined in trans/check.str) ])
