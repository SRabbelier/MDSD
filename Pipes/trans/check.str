module check

imports
  libstratego-lib
  include/Pipes
  lib/editor-common.generated

rules

  // Analysis: does a topdown traversal of the tree,
  // and tries to apply the record-entity rule.
  analyze:
    t -> t
    with
      <topdown(try(record-pipe))> t

  // Records the definition of an entity in a dynamic rule GetEntity.
  record-pipe:
    p@Pipe(PipeName(x), _, _, _, _) -> p
    with
      // For a name 'x', GetPipe will return the original 'x' tree node
      rules(
        GetCustom :+ x -> p
    	GetPipe :+ x -> p
      )
  record-pipe:
    n@Native(PipeName(x), _, _, _) -> n
    with
      rules(
    	GetNative :+ x -> n
    	GetPipe :+ x -> n
      )
  
	
	
rules
  eq-len:
  	[[a|a'], [b|b']] -> res
  	where res := <eq-len>[a', b']
  eq-len:
  	[[], [_]] -> <fail>
  eq-len:
  	[[_], []] -> <fail>
  eq-len:
  	[[], []] -> <id>
        
  get-args:
  	LambdaFunction(_, None()) -> []  
  	
  get-args:
  	LambdaFunction(_, FunctionArguments(t)) -> t

  get-args:
  	Pipe(_, _, NoArguments(), _, _) -> []

  get-args:
  	Pipe(_, _, Arguments(ArgumentList(a)), _, _) -> a
  
  get-args:
  	Native(_, _, NoArguments(), _) -> []
	  
  get-args:
  	Native(_, _, Arguments(ArgumentList(a)), _) -> a

  get-inputs:
  	Pipe(_, NoInput(), _, _, _) -> []
  get-inputs:
  	Pipe(_, ImplicitInput(), _, _, _) -> [Stream("stream")]
  get-inputs:
  	Pipe(_, ExplicitInput(StreamList(list)), _, _, _) -> list

  get-inputs:
  	Native(_, NoInput(), _, _) -> []
  get-inputs:
  	Native(_, ImplicitInput(), _, _) -> [Stream("stream")]
  get-inputs:
  	Native(_, ExplicitInput(StreamList(list)), _, _) -> list

  checkParam(|target):
  	[[DefaultedArgument(_, param)|rest], args] -> errs
  	with errs :=  <checkParam(|target)>[rest, args]

  checkParam(|target):
  	[[Argument(Variable(param))|rest], args] -> errors
  	with errs :=  <checkParam(|target)>[rest, args]
  	with (<fetch-elem(?FunctionArgument(_, param))> args) < errors:=errs + errors:=<missingParam(|errs, target)>param
  
  checkParam(|target):
  	[[], _] -> []	

  missingParam(|errors, target):
  	x -> [(target, $[Missing argument '[x]']), errors]
  
  hasParam(|x):
  	param -> <id>
  	where <fetch-elem(?Argument(Variable(x)))>param <+ <fetch-elem(?DefaultedArgument(_, Variable(x)))>param 
  
  checkArgs:
  	[param, [f@FunctionArgument(_,x)|rest]] -> errors
  	with errs := <checkArgs>[param, rest]
  	with (<hasParam(|x)>param) <  errors:=<id>errs + errors:=<invArg(|errs)>f

  checkArgs:
  	[_, []] -> []

  invArg(|errors):
  	f@FunctionArgument(_,x) -> [(f, $[Invalid argument '[x]']), errors]

  is-empty:
  	[] -> <id>
  is-empty:
  	[_] -> <fail>
  	
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    LambdaFunction(p@PipeName(name), _) -> (p, $[Pipe '[name]' is not defined])
    where
      not(<GetPipe> name) // no entity for this type
  
  constraint-error:
  	LambdaFunction(PipeName(name), Some(FunctionArguments(args))) -> <concat>[errors, errors2]
    where pargs := <get-args><GetPipe> name 
	  // Check that all arguments are expected parameters
    with errors := <checkArgs>[pargs, args]
    with errors2 := <checkParam(|name)>[pargs, args]
    
  constraint-error:
	  // Check that all required arguments are provided
  	f@LambdaFunction(PipeName(name), None()) -> errors
    where pargs := <get-args><GetPipe>name
    with errors := <checkParam(|name)>[pargs, []]
    
  constraint-error:
  	FunctionApplication(_, LambdaFunction(PipeName(name),_), ApplyFunction(ApplicationTarget(StreamList(input)))) -> (name, $[Expected [expected_size] streams but got [actual_size]])
  	with actual_size := <length>input
  	where p := <GetPipe>name
  	with expected_input := <get-inputs>p
  	with expected_size := <length>expected_input
  	// where not(<eq>[expected_size, actual_size]) // LOLWTF?!!OMGBBQ
  	where not(<eq-len>[input, expected_input]) 
  	
  // Reports an error if an entity is defined more than once.
  // This constraint is implemented by testing if the "bag" of
  // all entities x is not a singleton list.
  constraint-error:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Duplicate pipe name '[x]'])
    where
      not(<bagof-GetCustom> x => [_])

  constraint-error:
    Native(PipeName(x), _, _, _) -> (x, $[Duplicate native name '[x]'])
    where
      not(<bagof-GetNative> x => [_])
  
  constraint-warning:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Shadowing native pipe])
    where
      (<GetNative> x)
  
  constraint-note:
    Pipe(x@PipeName("Tim"), _, _, _, _) -> (x, $[You are an incredible machine.])

  constraint-note:
    Pipe(x@PipeName("Sverre"), _, _, _, _) -> (x, $[You are a CLI addict])
