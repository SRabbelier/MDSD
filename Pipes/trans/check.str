module check

imports
  libstratego-lib
  include/Pipes
  lib/editor-common.generated

rules

  // Analysis: does a topdown traversal of the tree,
  // and tries to apply the record-entity rule.
  analyze:
    t -> t
    with
      <topdown(try(record-entity))> t

  // Records the definition of an entity in a dynamic rule GetEntity.
  record-entity:
    p@Pipe(PipeName(x), _, _, _, _) -> p
    with
      // For a name 'x', GetPipe will return the original 'x' tree node
      rules(
        GetCustom :+ x -> p
    	GetPipe :+ x -> p
      )
  record-entity:
    n@Native(PipeName(x), _, _, _) -> n
    with
      rules(
    	GetNative :+ x -> n
    	GetPipe :+ x -> n
      )
  
	
	
rules
      
  get-args:
  	LambdaFunction(_, None()) -> []  
  	
  get-args:
  	LambdaFunction(_, FunctionArguments(t)) -> t

  get-args:
  	Pipe(_, _, NoArguments(), _, _) -> []

  get-args:
  	Pipe(_, _, Arguments(VariableList(a)), _, _) -> a
  
  get-args:
  	Native(_, _, NoArguments(), _) -> []
	  
  get-args:
  	Native(_, _, Arguments(VariableList(a)), _) -> a

  get-inputs:
  	Pipe(_, NoInput(), _, _, _) -> []
  get-inputs:
  	Pipe(_, ImplicitInput(), _, _, _) -> [Stream("stream")]
  get-inputs:
  	Pipe(_, ExplicitInput(StreamList(list)), _, _, _) -> list

  get-inputs:
  	Native(_, NoInput(), _, _) -> []
  get-inputs:
  	Native(_, ImplicitInput(), _, _) -> [Stream("stream")]
  get-inputs:
  	Native(_, ExplicitInput(StreamList(list)), _, _) -> list

  checkParam(|target):
  	[[Variable(param)|rest], args] -> errors
  	where errs :=  <checkParam(|target)>[rest, args] 
  	where (<fetch-elem(?FunctionArgument(_, param))> args) < errors:=<id>errs + errors:=<missingParam(|errs, target)>param
  
  checkParam(|target):
  	[[], _] -> []	

  missingParam(|errors, target):
  	x -> [(target, $[Missing argument '[x]']), errors]
  
  checkArgs:
  	[param, [f@FunctionArgument(_,x)|rest]] -> errors
  	where errs := <checkArgs>[param, rest]
  	where (<fetch-elem(?Variable(x))> param) <  errors:=<id>errs + errors:=<invArg(|errs)>f

  checkArgs:
  	[_, []] -> []

  invArg(|errors):
  	f@FunctionArgument(_,x) -> [(f, $[Invalid argument '[x]']), errors]

  is-empty:
  	[] -> <id>
  is-empty:
  	[_] -> <fail>
  	
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    LambdaFunction(p@PipeName(name), _) -> (p, $[Pipe '[name]' is not defined])
    where
      not(<GetPipe> name) // no entity for this type
  
  constraint-error:
  	LambdaFunction(PipeName(name), Some(FunctionArguments(args))) -> <concat>[errors, errors2]
    where pargs := <get-args><GetPipe> name 
	  // Check that all arguments are expected parameters
    where errors := <checkArgs>[pargs, args]
    where errors2 := <checkParam(|name)>[pargs, args]
    
  constraint-error:
	  // Check that all required arguments are provided
  	f@LambdaFunction(PipeName(name), None()) -> errors
    where pargs := <get-args><GetPipe>name
    where errors := <checkParam(|name)>[pargs, []]
    
  constraint-error:
  	FunctionApplication(_, LambdaFunction(PipeName(name), _), ApplyFunction(None())) -> (name, $[Expected [expected_size] arguments but got (one) implicit stream])  
  	where expected_size := <GetPipe; debug(!"Pipe "); get-inputs; debug(!"inputs "); length>name
  	where not(<eq>[expected_size, 1]) 
  constraint-error:
  	FunctionApplication(_, LambdaFunction(PipeName(name),_), ApplyFunction(Some(ApplicationTarget(StreamList(input))))) -> (name, $[Expected [expected_size] arguments but got [actual_size]])
  	where actual_size := <length>input
  	where expected_size := <GetPipe; get-inputs; length>name
  	where not(<eq>[expected_size, actual_size]) 
  	
  // Reports an error if an entity is defined more than once.
  // This constraint is implemented by testing if the "bag" of
  // all entities x is not a singleton list.
  constraint-error:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Duplicate pipe name '[x]'])
    where
      not(<bagof-GetCustom> x => [_])

  constraint-error:
    Native(PipeName(x), _, _, _) -> (x, $[Duplicate native name '[x]'])
    where
      not(<bagof-GetNative> x => [_])
  
  constraint-warning:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Shadowing native pipe])
    where
      (<GetNative> x)
  
  constraint-note:
    Pipe(x@PipeName("Tim"), _, _, _, _) -> (x, $[You are an incredible machine.])

  constraint-note:
    Pipe(x@PipeName("Sverre"), _, _, _, _) -> (x, $[You are a CLI addict])
