module check

imports
  libstratego-lib
  include/Pipes
  lib/editor-common.generated
  analyze
  rename
	
rules
  eq-len:
  	[[a|a'], [b|b']] -> res
  	where res := <eq-len>[a', b']
  eq-len:
  	[[], [_]] -> <fail>
  eq-len:
  	[[_], []] -> <fail>
  eq-len:
  	[[], []] -> <id>
        
  get-args:
  	LambdaFunction(_, None()) -> []  
  	
  get-args:
  	LambdaFunction(_, FunctionArguments(t)) -> t

  get-args:
  	Pipe(_, _, NoArguments(), _, _) -> []

  get-args:
  	Pipe(_, _, Arguments(ArgumentList(a)), _, _) -> a
  
  get-args:
  	Native(_, _, NoArguments(), _) -> []
	  
  get-args:
  	Native(_, _, Arguments(ArgumentList(a)), _) -> a

  get-inputs:
  	Pipe(_, NoInput(), _, _, _) -> []
  get-inputs:
  	Pipe(_, ImplicitInput(), _, _, _) -> [Stream("stream")]
  get-inputs:
  	Pipe(_, ExplicitInput(StreamList(list)), _, _, _) -> list

  get-outputs:
	Pipe(_, _, _, _, ImplicitOutput()) -> [Stream("stream")]

  get-outputs:
	Pipe(_, _, _, _, ExplicitOutput(StreamList(list))) -> list
	
  checkParam(|target):
  	[[DefaultedArgument(_, param)|rest], args] -> errs
  	with errs :=  <checkParam(|target)>[rest, args]

  checkParam(|target):
  	[[Argument(Variable(param))|rest], args] -> errors
  	with errs :=  <checkParam(|target)>[rest, args]
  	with (<fetch-elem(?FunctionArgument(_, param))> args) < errors:=errs + errors:=<missingParam(|errs, target)>param
  
  checkParam(|target):
  	[[], _] -> []	

  missingParam(|errors, target):
  	x -> [(target, $[Missing argument '[x]']), errors]
  
  hasParam(|x):
  	param -> <id>
  	where <fetch-elem(?Argument(Variable(x)))>param <+ <fetch-elem(?DefaultedArgument(_, Variable(x)))>param 
  
  checkArgs:
  	[param, [f@FunctionArgument(_,x)|rest]] -> errors
  	with errs := <checkArgs>[param, rest]
  	with (<hasParam(|x)>param) <  errors:=<id>errs + errors:=<invArg(|errs)>f

  checkArgs:
  	[_, []] -> []

  invArg(|errors):
  	f@FunctionArgument(_,x) -> [(x, $[Invalid argument '[x]']), errors]

  is-empty:
  	[] -> <id>
  is-empty:
  	[_] -> <fail>

  	
  stream-initialised(|target):
  	s@Stream(name) -> error
  	with <InitStream>name < error:=[] + error:= (target, $[Stream $[name] not initialised])
  	
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    LambdaFunction(p@PipeName(name), _) -> (p, $[Pipe '[name]' is not defined])
    where
      not(<GetPipe> name) // no entity for this type
  
  constraint-error:
  	LambdaFunction(PipeName(name), Some(FunctionArguments(args))) -> <concat>[errors, errors2]
    where pargs := <get-args><GetPipe> name 
	  // Check that all arguments are expected parameters
    with errors := <checkArgs>[pargs, args]
    with errors2 := <checkParam(|name)>[pargs, args]
    
  constraint-error:
	  // Check that all required arguments are provided
  	f@LambdaFunction(PipeName(name), None()) -> errors
    where pargs := <get-args><GetPipe>name
    with errors := <checkParam(|name)>[pargs, []]
    
  constraint-error:
  	FunctionApplication(_, LambdaFunction(PipeName(name),_), ApplyFunction(ApplicationTarget(StreamList(input)))) -> (name, $[Pipe '[name]' expects [expected_size] streams but got [actual_size]])
  	with actual_size := <length>input
  	where p := <GetPipe>name
  	with expected_input := <get-inputs>p
  	with expected_size := <length>expected_input
  	// where not(<eq>[expected_size, actual_size]) // LOLWTF?!!OMGBBQ
  	where not(<eq-len>[input, expected_input]) 

  constraint-error:
  	FunctionApplication(MultipleStreamAssignment(StreamList(streams)), LambdaFunction(PipeName(name),_),_) -> (name, $[Pipe '[name]' returns [expected_size] streams but only [actual_size] assigned])
  	with actual_size := <length>streams
  	where p:= <GetPipe>name
  	with expected_input := <get-outputs>p
  	with expected_size := <length>expected_input
  	where not(<eq-len>[streams, expected_input])
  	
  constraint-error:
  	Pipe(_, _, _, _, out@ExplicitOutput(StreamList(streams))) -> errors2
//  	with errors1 := <collect-all(constraint-error, conc)>stats
  	with errors2 := <map(stream-initialised(|out))>streams
  	// with <debug(!"Errors ")>errors2
  	
  constraint-error:
  	app@ApplyFunction(ApplicationTarget(StreamList(streams))) -> errors
  	with errors := <map(stream-initialised(|app))>streams

  constraint-error:
  	var@Variable(name) -> (var, $[Variable [name] is not initialized])
  	where not(<InitVariable>name)
  
  // Reports an error if an entity is defined more than once.
  // This constraint is implemented by testing if the "bag" of
  // all entities x is not a singleton list.
  constraint-error:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Duplicate pipe name '[x]'])
    where
      not(<bagof-GetCustom> x => [_])

  constraint-error:
    Native(PipeName(x), _, _, _) -> (x, $[Duplicate native name '[x]'])
    where
      not(<bagof-GetNative> x => [_])
  
  constraint-error:
  	Load(x) -> (x, $[Could not load module '[x]'])
  	where
  	  <FailedImports>x
  
  constraint-warning:
    Pipe(PipeName(x), _, _, _, _) -> (x, $[Shadowing native pipe])
    where
      (<GetNative> x)
  
  constraint-note:
    Pipe(x@PipeName("Tim"), _, _, _, _) -> (x, $[You are an incredible machine.])

  constraint-note:
    Pipe(x@PipeName("Sverre"), _, _, _, _) -> (x, $[You are a CLI addict])
