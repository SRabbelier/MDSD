module check

imports
  libstratego-lib
  include/Pipes
  lib/editor-common.generated

rules

  // Analysis: does a topdown traversal of the tree,
  // and tries to apply the record-entity rule.
  analyze:
    t -> t
    with
      <topdown(try(record-entity))> t

  // Records the definition of an entity in a dynamic rule GetEntity.
  record-entity:
    Pipe(x, _, _, _, _) -> <id>
    with
      // For a name 'x', GetPipe will return the original 'x' tree node
      rules(
        GetPipe :+ x -> <id>
      )
  record-entity:
    Native(x, _, _, _) -> <id>
    with
      rules(
    	GetPipe :+ x -> <id>
      )
	
	
rules
      
  get-name:
  	FunctionApplication(p, t) -> p
  
  get-args:
  	LambdaFunction(None(), _) -> []  
  	
  get-args:
  	LambdaFunction(FunctionArguments(t), _) -> t

  get-args:
  	Pipe(_, _, NoArguments(), _, _) -> []

  get-args:
  	Pipe(_, _, Arguments(VariableList(a)), _, _) -> a
  
  get-args:
  	Native(_, _, NoArguments(), _) -> []
	  
  get-args:
  	Native(_, _, Arguments(VariableList(a)), _) -> a
	  

  
  intersect:
  	[[a|a'], [b|b']] -> <id>	
  	where <intersect>[a', b']
  	  when a.ID = b.Id
  	
  // Reports an error if a property type is undefined.
  // This error is reported on the type name 'type'.
  constraint-error:
    FunctionApplication(p, t) -> (p, $[Pipe [p] is not defined])
    where
      not(<GetPipe> p) // no entity for this type
  
  constraint-error:
  	FunctionApplication(pname, t) -> (p, $[Pipe [p] is not defined])
    where
      p := <GetPipe> pname // no entity for this type
//      <argument-constraint-error|p>t

  	
  constraint-error:
  	LambdaFunction(arg, app) -> (p, $[Pipe [p] is not defined])
    where  p := <get-name>app
      ; pipe := <GetPipe> p 
      ; <intersect>[pipe, arg]
  	
  // Reports an error if an entity is defined more than once.
  // This constraint is implemented by testing if the "bag" of
  // all entities x is not a singleton list.
  constraint-error:
    Entity(x, _) -> (x, $[Duplicate entity name])
    where
      not(<bagof-GetPipe> x => [_])
  
  constraint-warning:
    Entity(x, _) -> (x, $[Entity names must start with a capital])
    where
      not(<explode-string; Hd; is-upper> x)
  
  constraint-note:
    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
                                      (this note is defined in trans/check.str) ])
