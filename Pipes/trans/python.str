module python

imports
    libstratego-lib
    libstratego-gpp
    libstratego-aterm
    include/Pipes
    lib/editor-common.generated
    lib/StrategoPython

rules
  to-stream-args : NoInput() -> []

  to-stream-args : ImplicitInput() -> ["stream"]

  extract-variables : Argument(v) -> v
  extract-variables : DefaultedArgument(_, v) -> v

  extract-stream : Stream(v) -> result
  with result := <concat-strings>["stream_", v]

  extract-keyword-args : Variable(v) -> result
  with result := <concat-strings>["arg_", v, "=None"]

  to-stream-args : ExplicitInput(StreamList(vars)) -> result
  with result := <map(extract-stream)>vars

  to-value-args : NoArguments() -> []

  to-value-args : Arguments(ArgumentList(vars)) -> result
  with result := <map(extract-keyword-args)>vars

  to-output-args : ExplicitOutput(StreamList(vars)) -> result
  with e := <map(extract-stream)>vars
  with result := python|[return e;]|

  python-header = !python*|[
	import sys;
	import logging;
	from pipes_builtins import ident;
	from pipes_builtins import streamToString;
	from pipes_builtins import streamSize;
	from pipes_builtins import isEmpty;
	from pipes_builtins import main_const;
	run_pipes = [];
  ]|

  python-after = !python*|[
		def main(args): {
			for pipe in run_pipes: {
				result = pipe();
				print streamToString(result);
			};
		};
	    if __name__ == main_const: {
			main(sys.argv);
	    };
  ]|

  to-python :
    Module(declarations) -> python*|[
	  stm1*
      stm
      stm2*
    ]|
    with stm1* := <python-header>
    with stm2* := <python-after>
    with stm := <map(to-python)>declarations

  to-python : Load(name) -> python|[from x import *;]|
  with x := name

  to-python : Variable(name) -> name

  to-python : Selector(Selection(selection)) -> result
  with joined := <separate-by(|"/"); concat-strings>selection
  with result := <concat-strings>["selector('", joined, "')"]

  to-python : All() -> "all"

  to-python : String(value) -> value

  to-python : Integer(value) -> value

  function-name : LambdaFunction(PipeName(name), _) -> result
  with result := <concat-strings>["lambda: func_", name]

  extract-function-streams : ApplyFunction(None()) -> ["stream_stream"]

  extract-function-streams : ApplyFunction(ApplicationTarget(StreamList(vars))) -> result
  with result := <map(extract-stream)>vars

  extract-function-streams : ExtractFunction() -> []

  extract-function-arg : FunctionArgument(y, x) -> result
  with y' := <to-python>y
  with name := <concat-strings>["arg_", x]
  with result := NamedParam(name,y')

  extract-function-args : None() -> []

  extract-function-args : Some(FunctionArguments(args)) -> result
  with result := <map(extract-function-arg)>args

  function-args(|app) : LambdaFunction(_, args) -> result
  with function_streams := <extract-function-streams>app
  with function_args := <extract-function-args>args
  with result := <concat>[function_streams, function_args]

  lambda-to-python(|app) : LambdaFunction(name, args) -> result
  with x_funcname := <function-name>
  with pe0* := <function-args(|app)>
  with result := py-exp|[
	ident(x_funcname(pe0*))
  ]|

  to-python : FunctionApplication(MultipleStreamAssignment(StreamList(list)), func, appl) -> python*|[
	x_streamname = e();
	logging.debug(streamSize(x_streamname));
  ]|
  with x_streamname := <map(extract-stream); separate-by(|","); concat-strings>list
  with e := <lambda-to-python(|appl)>func

  to-python : IsEmptyCondition(Stream(name)) -> py-exp|[isEmpty(x)]|
  with x := <concat-strings>["stream_", name]

  to-python : Then(t) -> python*|[
	stm*
  ]|
  with stm* := <map(to-python)>t

  to-python : NoThen() -> python*|[
	pass;
  ]|

  to-python : Else(t) -> python*|[
	stm*
  ]|
  with stm* := <map(to-python)>t

  to-python : NoElse() -> python*|[
	pass;
  ]|

  to-python : Conditional(If(t), then_block, else_block) -> [result]
  with e := <to-python>t
  with stm0* := <to-python>then_block
  with stm1* := <to-python>else_block
  with result := python|[
	if e: {
		stm0*
	} else: {
		stm1*
	};
  ]|

  to-python :
	Run(PipeName(name)) -> python|[run_pipes.append(e);]|
	with e := <concat-strings>["func_", name]

  to-python :
	Pipe(PipeName(name), input, arguments, statements, output) -> python*|[
		def x_name(e*): {
			stm*
			stm_ret
		};
		]|
		with x_name := <concat-strings> ["func_", name]
		with stream-args := <to-stream-args>input
		with value-args := <to-value-args>arguments
		with e* := <flatten-list>[stream-args, value-args]
		with stm_ret := <to-output-args>output
		with stm* := <map(to-python); concat>statements

  generate-python :
	Module(_) -> result
	with code := <to-python; flatten-list>
	with result := Application(code)

  pp-python :
  	ast -> s
  	where tbl := <import-term(lib/Python-pretty.pp.af)>
    where s := <ast2box(|[tbl]); box2text-string(|80)> ast
