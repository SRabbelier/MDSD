module python

imports
    libstratego-lib
    libstratego-gpp
    libstratego-aterm
    include/Pipes
    lib/editor-common.generated
    lib/StrategoPython

rules
  to-stream-args : NoInput() -> []

  to-stream-args : ImplicitInput() -> ["stream"]

  extract-variables : Argument(v) -> v
  extract-variables : DefaultedArgument(_, v) -> v

  extract-stream : Stream(v) -> v

  extract-keyword-args : Variable(v) -> result
  with result := <concat-strings>[v, "=None"]

  to-stream-args : ExplicitInput(StreamList(vars)) -> result
  with result := <map(extract-stream)>vars

  to-value-args : NoArguments() -> []

  to-value-args : Arguments(ArgumentList(vars)) -> result
  with result := <map(extract-keyword-args)>vars

  to-output-args : ExplicitOutput(StreamList(vars)) -> result
  with e := <map(extract-stream)>vars
  with result := python|[return e;]|

  python-header = !python*|[
	import sys;
	import logging;
	from pipes_builtins import *;
  ]|

  python-after = !python*|[
		def main(args): {
			pipe_main();
		};
	    if __name__ == '__main__': {
			main(sys.argv);
	    };
  ]|

  to-python :
    Start(declarations) -> python*|[
	  stm1*
      stm
      stm2*
    ]|
    with stm1* := <python-header>
    with stm2* := <python-after>
    with stm := <map(to-python)>declarations

  to-python : Load(_) -> []

  to-python : Variable(name) -> name

  to-python : Selector(Selection(selection)) -> result
  with joined := <separate-by(|"/"); concat-strings>selection
  with result := <concat-strings>["selector('", joined, "')"]

  to-python : All() -> "all"

  to-python : String(value) -> value

  to-python : Integer(value) -> value

  function-name : LambdaFunction(PipeName(name), _) -> result
  with result := <concat-strings>["lambda: func_", name]

  extract-function-streams : ApplyFunction(None()) -> ["stream"]

  extract-function-streams : ApplyFunction(ApplicationTarget(StreamList(vars))) -> result
  with result := <map(extract-stream)>vars

  extract-function-streams : ExtractFunction() -> []

  extract-function-arg : FunctionArgument(y, x) -> result
  with y' := <to-python>y
  with result := NamedParam(x,y')

  extract-function-args : None() -> []

  extract-function-args : Some(FunctionArguments(args)) -> result
  with result := <map(extract-function-arg)>args

  function-args(|app) : LambdaFunction(_, args) -> result
  with function_streams := <extract-function-streams>app
  with function_args := <extract-function-args>args
  with result := <concat>[function_streams, function_args]

  lambda-to-python(|app) : LambdaFunction(name, args) -> result
  with x_funcname := <function-name>
  with pe0* := <function-args(|app)>
  with result := py-exp|[
	ident(x_funcname(pe0*))
  ]|

  to-python : FunctionApplication(MultipleStreamAssignment(StreamList(list)), func, appl) -> python*|[
	x_streamname = e();
	logging.debug(x_streamname);
  ]|
  with x_streamname := <separate-by(|","); concat-strings>list
  with e := <lambda-to-python(|appl)>func

  to-python :
	Pipe(name, input, arguments, statements, output) -> python*|[
		def x_name(e*): {
			stm*
			stm_ret
		};
		]|
		with x_name := <concat-strings> ["pipe_", name]
		with stream-args := <to-stream-args>input
		with value-args := <to-value-args>arguments
		with e* := <flatten-list>[stream-args, value-args]
		with stm_ret := <to-output-args>output
		with stm* := <map(to-python); concat>statements

  generate-python :
	Start(_) -> result
	with code := <to-python; flatten-list>
	with result := Application(code)

  pp-python :
  	ast -> s
  	where tbl := <import-term(lib/Python-pretty.pp.af)>
    where s := <ast2box(|[tbl]); box2text-string(|80)> ast
