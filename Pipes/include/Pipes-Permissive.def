
definition

module Common
exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    ~[A-Za-z0-9\_]                 -> WATERTOKENSTART     {recover}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover}
    "*"                            -> WATERTOKENSTAR      {recover}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                                  
    "\""                                            -> INSERTOPENQUOTE21 {recover}
    INSERTOPENQUOTE21 StringChar* "\n"              -> STRING            {cons("INSERTEND")}
    INSERTOPENQUOTE21 StringChar* WATEREOF          -> STRING            {cons("INSERTEND")}
    "/*"                                            -> INSERTSTART21     {recover}
    INSERTSTART21 ( ~[\*] | CommentChar )* WATEREOF -> LAYOUT            {cons("INSERTEND")}
                                                    -> "pipe"            {recover, cons("INSERTION")}
                                                    -> "native"          {recover, cons("INSERTION")}
                                                    -> "load"            {recover, cons("INSERTION")}
                                                    -> "inputs"          {recover, cons("INSERTION")}
                                                    -> "arguments"       {recover, cons("INSERTION")}
                                                    -> "outputs"         {recover, cons("INSERTION")}
                                                    -> ","               {recover, cons("INSERTION")}
                                                    -> "applied"         {recover, cons("INSERTION")}
                                                    -> "to"              {recover, cons("INSERTION")}
                                                    -> "and"             {recover, cons("INSERTION")}
                                                    -> "]"               {recover, cons("INSERTION")}
                                                    -> "["               {recover, cons("INSERTION")}
                                                    -> "/"               {recover, cons("INSERTION")}
                                                    -> "$"               {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  (

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]*            -> ID            
    "-"? [0-9]+                        -> INT           
    "\"" StringChar* "\""              -> STRING        
    ~[\"\n]                            -> StringChar    
    "\\\""                             -> StringChar    
    BackSlashChar                      -> StringChar    
    "\\"                               -> BackSlashChar 
    [\ \t\n\r]                         -> LAYOUT        
    [\*]                               -> CommentChar   
    "/*" ( ~[\*] | CommentChar )* "*/" -> LAYOUT        
    "//" ~[\n\r]* [\n\r] | EOF         -> LAYOUT        
                                       -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

  )

module Pipes
imports Common

exports
  context-free start-symbols
    Start

  context-free syntax
    Declaration*                                      -> Start               {cons("Start")}
    "pipe" PipeName Input Arguments Statement* Output -> Declaration         {cons("Pipe")}
    "native" PipeName Input Arguments Output          -> Declaration         {cons("Native")}
    ID                                                -> PipeName            {cons("PipeName")}
    "load" ID                                         -> Load                {cons("Load")}
                                                      -> Input               {cons("NoInput")}
    "input"                                           -> Input               {cons("ImplicitInput")}
    "inputs" StreamList                               -> Input               {cons("ExplicitInput")}
                                                      -> Arguments           {cons("NoArguments")}
    "arguments" VariableList                          -> Arguments           {cons("Arguments")}
    "output"                                          -> Output              {cons("ImplicitOutput")}
    "outputs" StreamList                              -> Output              {cons("ExplicitOutput")}
    Stream "becomes"                                  -> StreamAssignment    {cons("StreamAssignment")}
    Variable "is"                                     -> Assignment          {cons("Assignment")}
    "," "using" FunctionArgument+ ","                 -> FunctionArguments   {cons("FunctionArguments")}
    Value "as" ID                                     -> FunctionArgument    {cons("FunctionArgument")}
    "applied" ApplicationTarget?                      -> FunctionType        {cons("ApplyFunction")}
    "extracted"                                       -> FunctionType        {cons("ExtractFunction")}
    ID                                                -> ExtractName         {cons("ExtractName")}
    "to" StreamList                                   -> ApplicationTarget   {cons("ApplicationTarget")}
    PipeName FunctionArguments?                       -> LambdaFunction      {cons("LambdaFunction")}
    StreamAssignment? LambdaFunction FunctionType     -> FunctionApplication {cons("FunctionApplication")}
    {Variable "and"}+                                 -> VariableList        {cons("VariableList")}
    {Stream "and"}+                                   -> StreamList          {cons("StreamList")}
    StatementYay "."                                  -> Statement           {cons("Statement")}
    Variable                                          -> Value               
    Selector                                          -> Value               
    LambdaFunction                                    -> Value               
    All                                               -> Value               
    String                                            -> Value               
    Integer                                           -> Value               
    FunctionApplication                               -> StatementYay        
    Load                                              -> StatementYay        
    "all"                                             -> All                 {cons("All")}
    STRING                                            -> String              {cons("String")}
    INT                                               -> Integer             {cons("Integer")}
    "[" Selection "]"                                 -> Selector            {cons("Selector")}
    {ID "/"}+                                         -> Selection           {cons("Selection")}
    "$" ID                                            -> Stream              {cons("Stream")}
    ID                                                -> Variable            {cons("Variable")}