definition
module Common

exports

  lexical syntax
  
    [a-zA-Z][a-zA-Z0-9\_]* -> ID
    "-"? [0-9]+            -> INT
    
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 
    
    BackSlashChar -/- [\"]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module Pipes

imports Common

exports

  context-free start-symbols
    Start

  context-free syntax
  
    Declaration*                                    -> Start {cons("Start")}
    
    "define" "pipe" PipeName Input Arguments Statement* Output     -> Declaration {cons("Pipe")}
    "define" "native" PipeName Input Arguments Output              -> Declaration {cons("Native")}
    
    ID												-> PipeName {cons("PipeName")}

    "load" ID                                       -> Load {cons("Load")}

    % epsilon %                                     -> Input {cons("NoInput")}
    "input"                                         -> Input {cons("ImplicitInput")}
    "inputs" StreamList                             -> Input {cons("ExplicitInput")}

    % epsilon %                                     -> Arguments {cons("NoArguments")}
    "arguments" VariableList                        -> Arguments {cons("Arguments")}

    "output"                          				-> Output {cons("ImplicitOutput")}
    "outputs" StreamList							-> Output {cons("ExplicitOutput")}

	% epsilon %										-> StreamAssignment {cons("ImplicitStreamAssignment")}
    Stream "becomes"                                -> StreamAssignment {cons("SingleStreamAssignment")}
    StreamList "become"                             -> StreamAssignment {cons("MultipleStreamAssignment")}

    Variable "is"		                            -> Assignment {cons("Assignment")}

    "," "using" FunctionArgument+ ","               -> FunctionArguments {cons("FunctionArguments")}
    Value "as" ID                                   -> FunctionArgument {cons("FunctionArgument")}

    "applied" ApplicationTarget                     -> FunctionType {cons("ApplyFunction")}
    "extracted"                                     -> FunctionType {cons("ExtractFunction")}
    ID												-> ExtractName {cons("ExtractName")}

	% epsilon %										-> ApplicationTarget {cons("ImplicitApplicationTarget")}
    "to" StreamList  								-> ApplicationTarget {cons("ApplicationTarget")}

    PipeName FunctionArguments?                     -> LambdaFunction {cons("LambdaFunction")}
    "pipe" LambdaFunction							-> LambdaRef  {cons("LambdaRef")}

    StreamAssignment LambdaFunction FunctionType    -> FunctionApplication {cons("FunctionApplication")}

    {Variable "and"}+                               -> VariableList {cons("VariableList")}
    {Stream "and"}+                               	-> StreamList {cons("StreamList")}

	StatementYay "."								-> Statement {cons("Statement")}

    %% class membership
    Variable                                        -> Value
    Selector                                        -> Value
    LambdaRef	                                    -> Value
    All                                             -> Value
    String                                          -> Value
    Integer                                         -> Value
    FunctionApplication                             -> StatementYay
    Load                                            -> StatementYay

    %% primitves
    "all"                                           -> All {cons("All")}
    STRING                                          -> String {cons("String")}
    INT                                             -> Integer {cons("Integer")} 
    "[" Selection "]"                               -> Selector {cons("Selector")}
    { ID "/"}+										-> Selection {cons("Selection")}
    "$" ID                                          -> Stream {cons("Stream")}
	ID                                              -> Variable {cons("Variable")}