%% Grammar for the Pipes language
%% By default, based on an example "entities" syntax
module Pipes

imports Common

exports

  context-free start-symbols
    Start

  context-free syntax
  
    Declaration*                                    -> Start {cons("Start")}
    
    "pipe" PipeName Input Arguments Statement* Output     -> Declaration {cons("Pipe")}
    "native" PipeName Input Arguments Output              -> Declaration {cons("Native")}
    
    ID												-> PipeName {cons("PipeName")}

    "load" ID                                       -> Load {cons("Load")}

    % epsilon %                                     -> Input {cons("NoInput")}
    "input"                                         -> Input {cons("ImplicitInput")}
    "inputs" VariableList                           -> Input {cons("ExplicitInput")}

    % epsilon %                                     -> Arguments {cons("NoArguments")}
    "arguments" VariableList                        -> Arguments {cons("Arguments")}

    % epsilon %                                     -> Output {cons("NoOutput")}
    "output"                          				-> Output {cons("ImplicitOutput")}
    "outputs" VariableList							-> Output {cons("ExplicitOutput")}

    Variable "becomes"                              -> StreamAssignment {cons("Assignment")}
    Variable "is"		                            -> Assignment {cons("Assignment")}

    "with" FunctionArgument+                        -> FunctionArguments {cons("FunctionArguments")}
    ID "is" Value                                   -> FunctionArgument {cons("FunctionArgument")}

    "apply" PipeName ApplicationTarget?             -> FunctionApplication {cons("FunctionApplication")}
    "extract" ExtractName                           -> FunctionApplication {cons("FunctionExtraction")}
    ID												-> ExtractName {cons("ExtractName")}

    "to" VariableList								-> ApplicationTarget {cons("ApplicationTarget")}

    FunctionArguments? FunctionApplication          -> LambdaFunction {cons("LambdaFunction")}
    StreamAssignment? LambdaFunction                -> Function {cons("Function")}

    {Variable "and"}+                               -> VariableList {cons("VariableList")}

    %% class membership
    Variable                                        -> Value
    Selector                                        -> Value
    LambdaFunction                                  -> Value
    All                                             -> Value
    String                                          -> Value
    Integer                                         -> Value
    Function                                        -> Statement
    Load                                            -> Statement

    %% primitves
    "all"                                           -> All {cons("All")}
    STRING                                          -> String {cons("String")}
    INT                                             -> Integer {cons("Integer")} 
    "[" Selection "]"                               -> Selector {cons("Selector")}
    { ID "/"}+										-> Selection {cons("Selection")}
    "$" ID                                          -> Variable {cons("Variable")}
